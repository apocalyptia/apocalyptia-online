import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, J as validate_each_argument, u as validate_store, w as component_subscribe, v as validate_slots, e as element, t as text, b as space, f as claim_element, g as children, k as claim_text, j as claim_space, h as detach_dev, l as attr_dev, m as add_location, Q as add_render_callback, p as insert_dev, n as append_dev, R as select_option, G as listen_dev, K as set_data_dev, L as destroy_each, H as run_all, r as noop, T as select_value, E as set_store_value, N as createEventDispatcher, O as onDestroy, F as group_outros, A as transition_out, B as check_outros, C as transition_in, x as create_component, y as claim_component, z as mount_component, D as destroy_component, X as empty, Y as beforeUpdate, q as query_selector_all } from './client.47a70721.js';
import { c as character } from './characterStore.39c7bd5f.js';
import './SWBodyguard.54177d3a.js';
import './AppendToGUUID.176d1458.js';
import './Skills.35c4252b.js';
import './Specialty.adf26afb.js';
import './ConstitutionSkills.56e093ee.js';
import './RandomRoll.f18d347c.js';
import './Traits.2656d3ca.js';
import { A as Abilities } from './Abilities.5f272c11.js';

/* src/components/views/character/AbilityCurrent.svelte generated by Svelte v3.29.0 */
const file = "src/components/views/character/AbilityCurrent.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[5] = list;
	child_ctx[6] = i;
	return child_ctx;
}

// (22:6) {#if ability.opts[0]}
function create_if_block(ctx) {
	let t0;
	let t1_value = /*ability*/ ctx[4].opts[0].name + "";
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = text(" (");
			t1 = text(t1_value);
			t2 = text(")");
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, " (");
			t1 = claim_text(nodes, t1_value);
			t2 = claim_text(nodes, ")");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && t1_value !== (t1_value = /*ability*/ ctx[4].opts[0].name + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(22:6) {#if ability.opts[0]}",
		ctx
	});

	return block;
}

// (34:7) {#each Array(ability.max+1) as _, i}
function create_each_block_1(ctx) {
	let option;
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(/*i*/ ctx[9]);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, /*i*/ ctx[9]);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = option_value_value = /*i*/ ctx[9];
			option.value = option.__value;
			add_location(option, file, 34, 8, 1037);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(34:7) {#each Array(ability.max+1) as _, i}",
		ctx
	});

	return block;
}

// (18:3) {#each $character.abilities as ability}
function create_each_block(ctx) {
	let div;
	let span0;
	let t0_value = /*ability*/ ctx[4].name + "";
	let t0;
	let t1;
	let t2;
	let span1;
	let t3_value = /*ability*/ ctx[4].xp + "";
	let t3;
	let t4;
	let span2;
	let t5_value = /*ability*/ ctx[4].max + "";
	let t5;
	let t6;
	let span3;
	let select;
	let t7;
	let mounted;
	let dispose;
	let if_block = /*ability*/ ctx[4].opts[0] && create_if_block(ctx);
	let each_value_1 = Array(/*ability*/ ctx[4].max + 1);
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function select_change_handler() {
		/*select_change_handler*/ ctx[2].call(select, /*each_value*/ ctx[5], /*ability_index*/ ctx[6]);
	}

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			span2 = element("span");
			t5 = text(t5_value);
			t6 = space();
			span3 = element("span");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t7 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span0 = claim_element(div_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			t1 = claim_space(span0_nodes);
			if (if_block) if_block.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			span1 = claim_element(div_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t3 = claim_text(span1_nodes, t3_value);
			span1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			span2 = claim_element(div_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t5 = claim_text(span2_nodes, t5_value);
			span2_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			span3 = claim_element(div_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			select = claim_element(span3_nodes, "SELECT", { class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			span3_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "l-col svelte-35kn9a");
			add_location(span0, file, 19, 5, 554);
			attr_dev(span1, "class", "s-col svelte-35kn9a");
			add_location(span1, file, 25, 5, 692);
			attr_dev(span2, "class", "s-col svelte-35kn9a");
			add_location(span2, file, 26, 5, 737);
			attr_dev(select, "class", "taken-number");
			if (/*ability*/ ctx[4].taken === void 0) add_render_callback(select_change_handler);
			add_location(select, file, 28, 6, 810);
			attr_dev(span3, "class", "s-col svelte-35kn9a");
			add_location(span3, file, 27, 5, 783);
			attr_dev(div, "class", "current-ability-row svelte-35kn9a");
			add_location(div, file, 18, 4, 515);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			if (if_block) if_block.m(span0, null);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
			append_dev(div, t4);
			append_dev(div, span2);
			append_dev(span2, t5);
			append_dev(div, t6);
			append_dev(div, span3);
			append_dev(span3, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*ability*/ ctx[4].taken);
			append_dev(div, t7);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", select_change_handler),
					listen_dev(select, "blur", /*blur_handler*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$character*/ 2 && t0_value !== (t0_value = /*ability*/ ctx[4].name + "")) set_data_dev(t0, t0_value);

			if (/*ability*/ ctx[4].opts[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(span0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*$character*/ 2 && t3_value !== (t3_value = /*ability*/ ctx[4].xp + "")) set_data_dev(t3, t3_value);
			if (dirty & /*$character*/ 2 && t5_value !== (t5_value = /*ability*/ ctx[4].max + "")) set_data_dev(t5, t5_value);

			if (dirty & /*$character*/ 2) {
				each_value_1 = Array(/*ability*/ ctx[4].max + 1);
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty & /*$character*/ 2) {
				select_option(select, /*ability*/ ctx[4].taken);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(18:3) {#each $character.abilities as ability}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div4;
	let div0;
	let t0;
	let t1;
	let div3;
	let div1;
	let span0;
	let t2;
	let t3;
	let span1;
	let t4;
	let t5;
	let span2;
	let t6;
	let t7;
	let span3;
	let t8;
	let t9;
	let div2;
	let each_value = /*$character*/ ctx[1].abilities;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			t0 = text("Current Abilities");
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			span0 = element("span");
			t2 = text("Name");
			t3 = space();
			span1 = element("span");
			t4 = text("XP");
			t5 = space();
			span2 = element("span");
			t6 = text("Max");
			t7 = space();
			span3 = element("span");
			t8 = text("Taken");
			t9 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, "Current Abilities");
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span0 = claim_element(div1_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t2 = claim_text(span0_nodes, "Name");
			span0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			span1 = claim_element(div1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t4 = claim_text(span1_nodes, "XP");
			span1_nodes.forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			span2 = claim_element(div1_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t6 = claim_text(span2_nodes, "Max");
			span2_nodes.forEach(detach_dev);
			t7 = claim_space(div1_nodes);
			span3 = claim_element(div1_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			t8 = claim_text(span3_nodes, "Taken");
			span3_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t9 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "current-abilities-title svelte-35kn9a");
			add_location(div0, file, 8, 1, 139);
			attr_dev(span0, "class", "l-col svelte-35kn9a");
			add_location(span0, file, 11, 3, 285);
			attr_dev(span1, "class", "s-col svelte-35kn9a");
			add_location(span1, file, 12, 3, 320);
			attr_dev(span2, "class", "s-col svelte-35kn9a");
			add_location(span2, file, 13, 3, 353);
			attr_dev(span3, "class", "s-col svelte-35kn9a");
			add_location(span3, file, 14, 3, 387);
			attr_dev(div1, "class", "current-abilities-header svelte-35kn9a");
			add_location(div1, file, 10, 2, 243);
			attr_dev(div2, "class", "current-abilities-list");
			add_location(div2, file, 16, 2, 431);
			attr_dev(div3, "class", "current-abilities-section");
			add_location(div3, file, 9, 1, 201);
			attr_dev(div4, "class", "current-abilities svelte-35kn9a");
			add_location(div4, file, 7, 0, 106);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div0, t0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div1);
			append_dev(div1, span0);
			append_dev(span0, t2);
			append_dev(div1, t3);
			append_dev(div1, span1);
			append_dev(span1, t4);
			append_dev(div1, t5);
			append_dev(div1, span2);
			append_dev(span2, t6);
			append_dev(div1, t7);
			append_dev(div1, span3);
			append_dev(span3, t8);
			append_dev(div3, t9);
			append_dev(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$character, MasterAbilityList, Array*/ 3) {
				each_value = /*$character*/ ctx[1].abilities;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityCurrent", slots, []);
	let { MasterAbilityList } = $$props;
	const writable_props = ["MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityCurrent> was created with unknown prop '${key}'`);
	});

	function select_change_handler(each_value, ability_index) {
		each_value[ability_index].taken = select_value(this);
		character.set($character);
	}

	const blur_handler = () => set_store_value(character, $character.abilities = MasterAbilityList.filter(ability => ability.taken), $character);

	$$self.$$set = $$props => {
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({ character, MasterAbilityList, $character });

	$$self.$inject_state = $$props => {
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [MasterAbilityList, $character, select_change_handler, blur_handler];
}

class AbilityCurrent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { MasterAbilityList: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityCurrent",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*MasterAbilityList*/ ctx[0] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityCurrent> was created without expected prop 'MasterAbilityList'");
		}
	}

	get MasterAbilityList() {
		throw new Error("<AbilityCurrent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityCurrent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/AbilityModalSingle.svelte generated by Svelte v3.29.0 */
const file$1 = "src/components/views/character/AbilityModalSingle.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (21:4) {#each Array(ability.max+1) as _, i}
function create_each_block$1(ctx) {
	let option;
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(/*i*/ ctx[7]);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, /*i*/ ctx[7]);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = option_value_value = /*i*/ ctx[7];
			option.value = option.__value;
			add_location(option, file$1, 21, 5, 540);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(21:4) {#each Array(ability.max+1) as _, i}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div3;
	let div2;
	let div0;
	let t0_value = /*ability*/ ctx[0].name + "";
	let t0;
	let t1;
	let div1;
	let t2;
	let select;
	let select_name_value;
	let mounted;
	let dispose;
	let each_value = Array(/*ability*/ ctx[0].max + 1);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text("Taken:\n\t\t\t");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, "Taken:\n\t\t\t");
			select = claim_element(div1_nodes, "SELECT", { name: true, class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "ability-name-label");
			add_location(div0, file$1, 11, 2, 247);
			attr_dev(select, "name", select_name_value = /*ability*/ ctx[0].name);
			attr_dev(select, "class", "svelte-1sfjlhz");
			if (/*ability*/ ctx[0].taken === void 0) add_render_callback(() => /*select_change_handler*/ ctx[3].call(select));
			add_location(select, file$1, 15, 3, 344);
			attr_dev(div1, "class", "taken-label");
			add_location(div1, file$1, 14, 2, 309);
			attr_dev(div2, "class", "ability-section svelte-1sfjlhz");
			add_location(div2, file$1, 10, 1, 215);
			attr_dev(div3, "class", "options-section svelte-1sfjlhz");
			add_location(div3, file$1, 9, 0, 184);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div1, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*ability*/ ctx[0].taken);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler*/ ctx[3]),
					listen_dev(select, "blur", /*blur_handler*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*ability*/ 1 && t0_value !== (t0_value = /*ability*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*ability*/ 1) {
				each_value = Array(/*ability*/ ctx[0].max + 1);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*ability*/ 1 && select_name_value !== (select_name_value = /*ability*/ ctx[0].name)) {
				attr_dev(select, "name", select_name_value);
			}

			if (dirty & /*ability*/ 1) {
				select_option(select, /*ability*/ ctx[0].taken);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(2, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityModalSingle", slots, []);
	let { ability } = $$props, { MasterAbilityList } = $$props;
	ability = MasterAbilityList.filter(a => a.name == ability.name)[0];
	const writable_props = ["ability", "MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityModalSingle> was created with unknown prop '${key}'`);
	});

	function select_change_handler() {
		ability.taken = select_value(this);
		$$invalidate(0, ability);
	}

	const blur_handler = () => set_store_value(character, $character.abilities = MasterAbilityList.filter(a => a.taken), $character);

	$$self.$$set = $$props => {
		if ("ability" in $$props) $$invalidate(0, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({
		character,
		ability,
		MasterAbilityList,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("ability" in $$props) $$invalidate(0, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [ability, MasterAbilityList, $character, select_change_handler, blur_handler];
}

class AbilityModalSingle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { ability: 0, MasterAbilityList: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityModalSingle",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ability*/ ctx[0] === undefined && !("ability" in props)) {
			console.warn("<AbilityModalSingle> was created without expected prop 'ability'");
		}

		if (/*MasterAbilityList*/ ctx[1] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityModalSingle> was created without expected prop 'MasterAbilityList'");
		}
	}

	get ability() {
		throw new Error("<AbilityModalSingle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ability(value) {
		throw new Error("<AbilityModalSingle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MasterAbilityList() {
		throw new Error("<AbilityModalSingle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityModalSingle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/AbilityModalOptions.svelte generated by Svelte v3.29.0 */
const file$2 = "src/components/views/character/AbilityModalOptions.svelte";

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	child_ctx[10] = i;
	return child_ctx;
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	child_ctx[6] = list;
	child_ctx[7] = i;
	return child_ctx;
}

// (22:5) {#each Array(ability.max+1) as _, i}
function create_each_block_1$1(ctx) {
	let option;
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(/*i*/ ctx[10]);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, /*i*/ ctx[10]);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = option_value_value = /*i*/ ctx[10];
			option.value = option.__value;
			add_location(option, file$2, 22, 6, 595);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(22:5) {#each Array(ability.max+1) as _, i}",
		ctx
	});

	return block;
}

// (11:1) {#each OptionList as ability}
function create_each_block$2(ctx) {
	let div2;
	let div0;
	let t0_value = /*ability*/ ctx[1].opts[0].name + "";
	let t0;
	let t1;
	let div1;
	let t2;
	let select;
	let select_name_value;
	let t3;
	let mounted;
	let dispose;
	let each_value_1 = Array(/*ability*/ ctx[1].max + 1);
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	function select_change_handler() {
		/*select_change_handler*/ ctx[4].call(select, /*each_value*/ ctx[6], /*ability_index*/ ctx[7]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text("Taken:\n\t\t\t\t");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, "Taken:\n\t\t\t\t");
			select = claim_element(div1_nodes, "SELECT", { name: true, class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "ability-name-label");
			add_location(div0, file$2, 12, 3, 284);
			attr_dev(select, "name", select_name_value = /*ability*/ ctx[1].name);
			attr_dev(select, "class", "svelte-1sfjlhz");
			if (/*ability*/ ctx[1].taken === void 0) add_render_callback(select_change_handler);
			add_location(select, file$2, 16, 4, 393);
			attr_dev(div1, "class", "taken-label");
			add_location(div1, file$2, 15, 3, 357);
			attr_dev(div2, "class", "ability-section svelte-1sfjlhz");
			add_location(div2, file$2, 11, 2, 251);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div1, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*ability*/ ctx[1].taken);
			append_dev(div2, t3);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", select_change_handler),
					listen_dev(select, "blur", /*blur_handler*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*OptionList*/ 4 && t0_value !== (t0_value = /*ability*/ ctx[1].opts[0].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*OptionList*/ 4) {
				each_value_1 = Array(/*ability*/ ctx[1].max + 1);
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty & /*OptionList*/ 4 && select_name_value !== (select_name_value = /*ability*/ ctx[1].name)) {
				attr_dev(select, "name", select_name_value);
			}

			if (dirty & /*OptionList*/ 4) {
				select_option(select, /*ability*/ ctx[1].taken);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(11:1) {#each OptionList as ability}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let each_value = /*OptionList*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "options-section svelte-1sfjlhz");
			add_location(div, file$2, 9, 0, 188);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*OptionList, $character, MasterAbilityList, Array*/ 13) {
				each_value = /*OptionList*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(3, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityModalOptions", slots, []);
	let { ability } = $$props, { MasterAbilityList } = $$props;
	let OptionList = MasterAbilityList.filter(a => a.name == ability.name);
	const writable_props = ["ability", "MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityModalOptions> was created with unknown prop '${key}'`);
	});

	function select_change_handler(each_value, ability_index) {
		each_value[ability_index].taken = select_value(this);
		$$invalidate(2, OptionList);
	}

	const blur_handler = () => set_store_value(character, $character.abilities = MasterAbilityList.filter(a => a.taken), $character);

	$$self.$$set = $$props => {
		if ("ability" in $$props) $$invalidate(1, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({
		character,
		ability,
		MasterAbilityList,
		OptionList,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("ability" in $$props) $$invalidate(1, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
		if ("OptionList" in $$props) $$invalidate(2, OptionList = $$props.OptionList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		MasterAbilityList,
		ability,
		OptionList,
		$character,
		select_change_handler,
		blur_handler
	];
}

class AbilityModalOptions extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { ability: 1, MasterAbilityList: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityModalOptions",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ability*/ ctx[1] === undefined && !("ability" in props)) {
			console.warn("<AbilityModalOptions> was created without expected prop 'ability'");
		}

		if (/*MasterAbilityList*/ ctx[0] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityModalOptions> was created without expected prop 'MasterAbilityList'");
		}
	}

	get ability() {
		throw new Error("<AbilityModalOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ability(value) {
		throw new Error("<AbilityModalOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MasterAbilityList() {
		throw new Error("<AbilityModalOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityModalOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/AbilityModal.svelte generated by Svelte v3.29.0 */
const file$3 = "src/components/views/character/AbilityModal.svelte";

// (30:3) {:else}
function create_else_block(ctx) {
	let abilitymodalsingle;
	let current;

	abilitymodalsingle = new AbilityModalSingle({
			props: {
				ability: /*ability*/ ctx[0],
				MasterAbilityList: /*MasterAbilityList*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(abilitymodalsingle.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(abilitymodalsingle.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(abilitymodalsingle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const abilitymodalsingle_changes = {};
			if (dirty & /*ability*/ 1) abilitymodalsingle_changes.ability = /*ability*/ ctx[0];
			if (dirty & /*MasterAbilityList*/ 2) abilitymodalsingle_changes.MasterAbilityList = /*MasterAbilityList*/ ctx[1];
			abilitymodalsingle.$set(abilitymodalsingle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(abilitymodalsingle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitymodalsingle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(abilitymodalsingle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(30:3) {:else}",
		ctx
	});

	return block;
}

// (28:3) {#if ability.opts.length}
function create_if_block$1(ctx) {
	let abilitymodaloptions;
	let current;

	abilitymodaloptions = new AbilityModalOptions({
			props: {
				ability: /*ability*/ ctx[0],
				MasterAbilityList: /*MasterAbilityList*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(abilitymodaloptions.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(abilitymodaloptions.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(abilitymodaloptions, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const abilitymodaloptions_changes = {};
			if (dirty & /*ability*/ 1) abilitymodaloptions_changes.ability = /*ability*/ ctx[0];
			if (dirty & /*MasterAbilityList*/ 2) abilitymodaloptions_changes.MasterAbilityList = /*MasterAbilityList*/ ctx[1];
			abilitymodaloptions.$set(abilitymodaloptions_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(abilitymodaloptions.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitymodaloptions.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(abilitymodaloptions, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(28:3) {#if ability.opts.length}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div0;
	let t0;
	let div6;
	let div5;
	let div1;
	let h2;
	let t1_value = /*ability*/ ctx[0].name + "";
	let t1;
	let t2;
	let div2;
	let span0;
	let t3;
	let t4;
	let span1;
	let t5_value = /*ability*/ ctx[0].desc + "";
	let t5;
	let t6;
	let div3;
	let current_block_type_index;
	let if_block;
	let t7;
	let div4;
	let button;
	let t8;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*ability*/ ctx[0].opts.length) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div6 = element("div");
			div5 = element("div");
			div1 = element("div");
			h2 = element("h2");
			t1 = text(t1_value);
			t2 = space();
			div2 = element("div");
			span0 = element("span");
			t3 = text("Description:");
			t4 = space();
			span1 = element("span");
			t5 = text(t5_value);
			t6 = space();
			div3 = element("div");
			if_block.c();
			t7 = space();
			div4 = element("div");
			button = element("button");
			t8 = text("Close");
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(nodes);

			div6 = claim_element(nodes, "DIV", {
				class: true,
				role: true,
				"aria-modal": true
			});

			var div6_nodes = children(div6);
			div5 = claim_element(div6_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div1 = claim_element(div5_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h2 = claim_element(div1_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, t1_value);
			h2_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t2 = claim_space(div5_nodes);
			div2 = claim_element(div5_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			span0 = claim_element(div2_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t3 = claim_text(span0_nodes, "Description:");
			span0_nodes.forEach(detach_dev);
			t4 = claim_space(div2_nodes);
			span1 = claim_element(div2_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t5 = claim_text(span1_nodes, t5_value);
			span1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t6 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			if_block.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			t7 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			button = claim_element(div4_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t8 = claim_text(button_nodes, "Close");
			button_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-background svelte-1l8191m");
			add_location(div0, file$3, 18, 0, 566);
			attr_dev(h2, "class", "svelte-1l8191m");
			add_location(h2, file$3, 21, 28, 747);
			attr_dev(div1, "class", "ability-name svelte-1l8191m");
			add_location(div1, file$3, 21, 2, 721);
			attr_dev(span0, "class", "description-label svelte-1l8191m");
			add_location(span0, file$3, 23, 3, 816);
			attr_dev(span1, "class", "ability-description svelte-1l8191m");
			add_location(span1, file$3, 24, 3, 871);
			attr_dev(div2, "class", "description-section svelte-1l8191m");
			add_location(div2, file$3, 22, 2, 779);
			attr_dev(div3, "class", "stats-section svelte-1l8191m");
			add_location(div3, file$3, 26, 2, 938);
			attr_dev(button, "class", "svelte-1l8191m");
			add_location(button, file$3, 34, 3, 1164);
			attr_dev(div4, "class", "btn-row svelte-1l8191m");
			add_location(div4, file$3, 33, 2, 1139);
			attr_dev(div5, "class", "modal-content svelte-1l8191m");
			add_location(div5, file$3, 20, 1, 691);
			attr_dev(div6, "class", "modal svelte-1l8191m");
			attr_dev(div6, "role", "dialog");
			attr_dev(div6, "aria-modal", "true");
			add_location(div6, file$3, 19, 0, 638);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div6, anchor);
			append_dev(div6, div5);
			append_dev(div5, div1);
			append_dev(div1, h2);
			append_dev(h2, t1);
			append_dev(div5, t2);
			append_dev(div5, div2);
			append_dev(div2, span0);
			append_dev(span0, t3);
			append_dev(div2, t4);
			append_dev(div2, span1);
			append_dev(span1, t5);
			append_dev(div5, t6);
			append_dev(div5, div3);
			if_blocks[current_block_type_index].m(div3, null);
			append_dev(div5, t7);
			append_dev(div5, div4);
			append_dev(div4, button);
			append_dev(button, t8);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*handle_keydown*/ ctx[3], false, false, false),
					listen_dev(div0, "click", /*click_handler*/ ctx[4], false, false, false),
					listen_dev(button, "click", /*click_handler_1*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*ability*/ 1) && t1_value !== (t1_value = /*ability*/ ctx[0].name + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*ability*/ 1) && t5_value !== (t5_value = /*ability*/ ctx[0].desc + "")) set_data_dev(t5, t5_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div3, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div6);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityModal", slots, []);
	let { ability } = $$props, { MasterAbilityList } = $$props;
	const dispatch = createEventDispatcher();

	const handle_keydown = e => {
		if (e.key === "Escape") dispatch("close");
	};

	const previously_focused = typeof document !== "undefined" && document.activeElement;
	if (previously_focused) onDestroy(_ => previously_focused.focus());
	const writable_props = ["ability", "MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityModal> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch("close");
	const click_handler_1 = () => dispatch("close");

	$$self.$$set = $$props => {
		if ("ability" in $$props) $$invalidate(0, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onDestroy,
		AbilityModalSingle,
		AbilityModalOptions,
		ability,
		MasterAbilityList,
		dispatch,
		handle_keydown,
		previously_focused
	});

	$$self.$inject_state = $$props => {
		if ("ability" in $$props) $$invalidate(0, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ability,
		MasterAbilityList,
		dispatch,
		handle_keydown,
		click_handler,
		click_handler_1
	];
}

class AbilityModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { ability: 0, MasterAbilityList: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityModal",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ability*/ ctx[0] === undefined && !("ability" in props)) {
			console.warn("<AbilityModal> was created without expected prop 'ability'");
		}

		if (/*MasterAbilityList*/ ctx[1] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityModal> was created without expected prop 'MasterAbilityList'");
		}
	}

	get ability() {
		throw new Error("<AbilityModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ability(value) {
		throw new Error("<AbilityModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MasterAbilityList() {
		throw new Error("<AbilityModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var ToggleVisible = (x, y=null) => {
	x.visible = !x.visible;
	return y
};

/* src/components/views/character/AbilityCard.svelte generated by Svelte v3.29.0 */
const file$4 = "src/components/views/character/AbilityCard.svelte";

// (17:0) {#if ability.visible == true}
function create_if_block$2(ctx) {
	let abilitymodal;
	let current;

	abilitymodal = new AbilityModal({
			props: {
				ability: /*ability*/ ctx[1],
				MasterAbilityList: /*MasterAbilityList*/ ctx[0]
			},
			$$inline: true
		});

	abilitymodal.$on("close", /*close_handler*/ ctx[3]);

	const block = {
		c: function create() {
			create_component(abilitymodal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(abilitymodal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(abilitymodal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const abilitymodal_changes = {};
			if (dirty & /*ability*/ 2) abilitymodal_changes.ability = /*ability*/ ctx[1];
			if (dirty & /*MasterAbilityList*/ 1) abilitymodal_changes.MasterAbilityList = /*MasterAbilityList*/ ctx[0];
			abilitymodal.$set(abilitymodal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(abilitymodal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitymodal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(abilitymodal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(17:0) {#if ability.visible == true}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div2;
	let div0;
	let span0;
	let t0_value = /*ability*/ ctx[1].name + "";
	let t0;
	let t1;
	let div1;
	let span1;
	let t2_value = /*ability*/ ctx[1].desc + "";
	let t2;
	let t3;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*ability*/ ctx[1].visible == true && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			span1 = element("span");
			t2 = text(t2_value);
			t3 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span0 = claim_element(div0_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span1 = claim_element(div1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t2 = claim_text(span1_nodes, t2_value);
			span1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "ability-name svelte-kyd8dq");
			add_location(span0, file$4, 10, 2, 309);
			attr_dev(div0, "class", "card-row svelte-kyd8dq");
			add_location(div0, file$4, 9, 1, 284);
			attr_dev(span1, "class", "ability-description");
			add_location(span1, file$4, 13, 2, 392);
			attr_dev(div1, "class", "card-row svelte-kyd8dq");
			add_location(div1, file$4, 12, 1, 367);
			attr_dev(div2, "class", "ability-card svelte-kyd8dq");
			add_location(div2, file$4, 8, 0, 177);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, span0);
			append_dev(span0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, span1);
			append_dev(span1, t2);
			insert_dev(target, t3, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div2, "click", /*click_handler*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*ability*/ 2) && t0_value !== (t0_value = /*ability*/ ctx[1].name + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*ability*/ 2) && t2_value !== (t2_value = /*ability*/ ctx[1].desc + "")) set_data_dev(t2, t2_value);

			if (/*ability*/ ctx[1].visible == true) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*ability*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t3);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityCard", slots, []);
	let { ability } = $$props, { MasterAbilityList } = $$props;
	const writable_props = ["ability", "MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityCard> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, MasterAbilityList = ToggleVisible(ability, MasterAbilityList));
	const close_handler = () => $$invalidate(0, MasterAbilityList = ToggleVisible(ability, MasterAbilityList));

	$$self.$$set = $$props => {
		if ("ability" in $$props) $$invalidate(1, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({
		AbilityModal,
		ToggleVisible,
		ability,
		MasterAbilityList
	});

	$$self.$inject_state = $$props => {
		if ("ability" in $$props) $$invalidate(1, ability = $$props.ability);
		if ("MasterAbilityList" in $$props) $$invalidate(0, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [MasterAbilityList, ability, click_handler, close_handler];
}

class AbilityCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { ability: 1, MasterAbilityList: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityCard",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ability*/ ctx[1] === undefined && !("ability" in props)) {
			console.warn("<AbilityCard> was created without expected prop 'ability'");
		}

		if (/*MasterAbilityList*/ ctx[0] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityCard> was created without expected prop 'MasterAbilityList'");
		}
	}

	get ability() {
		throw new Error("<AbilityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ability(value) {
		throw new Error("<AbilityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MasterAbilityList() {
		throw new Error("<AbilityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/AbilityGroup.svelte generated by Svelte v3.29.0 */
const file$5 = "src/components/views/character/AbilityGroup.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (13:2) {#each group.list as ability}
function create_each_block$3(ctx) {
	let abilitycard;
	let current;

	abilitycard = new AbilityCard({
			props: {
				ability: /*ability*/ ctx[2],
				MasterAbilityList: /*MasterAbilityList*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(abilitycard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(abilitycard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(abilitycard, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const abilitycard_changes = {};
			if (dirty & /*group*/ 1) abilitycard_changes.ability = /*ability*/ ctx[2];
			if (dirty & /*MasterAbilityList*/ 2) abilitycard_changes.MasterAbilityList = /*MasterAbilityList*/ ctx[1];
			abilitycard.$set(abilitycard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(abilitycard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitycard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(abilitycard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(13:2) {#each group.list as ability}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let details;
	let summary;
	let t0_value = /*group*/ ctx[0].name + "";
	let t0;
	let t1;
	let t2;
	let div;
	let current;
	let each_value = /*group*/ ctx[0].list;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text(t0_value);
			t1 = text("XP Abilities");
			t2 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", {});
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, t0_value);
			t1 = claim_text(summary_nodes, "XP Abilities");
			summary_nodes.forEach(detach_dev);
			t2 = claim_space(details_nodes);
			div = claim_element(details_nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(summary, file$5, 8, 1, 148);
			attr_dev(div, "class", "ability-group-card");
			add_location(div, file$5, 11, 1, 198);
			attr_dev(details, "class", "ability-group-details svelte-ial7of");
			add_location(details, file$5, 7, 0, 107);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(summary, t1);
			append_dev(details, t2);
			append_dev(details, div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*group*/ 1) && t0_value !== (t0_value = /*group*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*group, MasterAbilityList*/ 3) {
				each_value = /*group*/ ctx[0].list;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AbilityGroup", slots, []);
	let { group } = $$props, { MasterAbilityList } = $$props;
	const writable_props = ["group", "MasterAbilityList"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AbilityGroup> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("group" in $$props) $$invalidate(0, group = $$props.group);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	$$self.$capture_state = () => ({ AbilityCard, group, MasterAbilityList });

	$$self.$inject_state = $$props => {
		if ("group" in $$props) $$invalidate(0, group = $$props.group);
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [group, MasterAbilityList];
}

class AbilityGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { group: 0, MasterAbilityList: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AbilityGroup",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*group*/ ctx[0] === undefined && !("group" in props)) {
			console.warn("<AbilityGroup> was created without expected prop 'group'");
		}

		if (/*MasterAbilityList*/ ctx[1] === undefined && !("MasterAbilityList" in props)) {
			console.warn("<AbilityGroup> was created without expected prop 'MasterAbilityList'");
		}
	}

	get group() {
		throw new Error("<AbilityGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<AbilityGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get MasterAbilityList() {
		throw new Error("<AbilityGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set MasterAbilityList(value) {
		throw new Error("<AbilityGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/character/creator/abilities.svelte generated by Svelte v3.29.0 */
const file$6 = "src/routes/character/creator/abilities.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (26:1) {#each Abilities.explanation as line}
function create_each_block_1$2(ctx) {
	let p;
	let t_value = /*line*/ ctx[7] + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$6, 26, 2, 808);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(26:1) {#each Abilities.explanation as line}",
		ctx
	});

	return block;
}

// (34:0) {#if $character.abilities.length}
function create_if_block$3(ctx) {
	let div;
	let abilitycurrent;
	let current;

	abilitycurrent = new AbilityCurrent({
			props: {
				MasterAbilityList: /*MasterAbilityList*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(abilitycurrent.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(abilitycurrent.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "section-card");
			add_location(div, file$6, 34, 1, 1067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(abilitycurrent, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(abilitycurrent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitycurrent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(abilitycurrent);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(34:0) {#if $character.abilities.length}",
		ctx
	});

	return block;
}

// (40:1) {#each Abilities.groups as group, index}
function create_each_block$4(ctx) {
	let abilitygroup;
	let current;

	abilitygroup = new AbilityGroup({
			props: {
				group: /*group*/ ctx[4],
				MasterAbilityList: /*MasterAbilityList*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(abilitygroup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(abilitygroup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(abilitygroup, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(abilitygroup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(abilitygroup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(abilitygroup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(40:1) {#each Abilities.groups as group, index}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let div0;
	let t3;
	let p;
	let t4;
	let t5;
	let div1;
	let h3;
	let t6;
	let t7_value = /*$character*/ ctx[0].props.experience.remaining + "";
	let t7;
	let t8;
	let t9;
	let div2;
	let t10;
	let div3;
	let button0;
	let t11;
	let t12;
	let button1;
	let t13;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = Abilities.explanation;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	let if_block = /*$character*/ ctx[0].abilities.length && create_if_block$3(ctx);
	let each_value = Abilities.groups;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			t0 = space();
			h1 = element("h1");
			t1 = text("Abilities");
			t2 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = space();
			p = element("p");
			t4 = text("Buy Abilities for your Character using XP, or save some or all of your starting XP for later.");
			t5 = space();
			div1 = element("div");
			h3 = element("h3");
			t6 = text("Remaining: ");
			t7 = text(t7_value);
			t8 = space();
			if (if_block) if_block.c();
			t9 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t10 = space();
			div3 = element("div");
			button0 = element("button");
			t11 = text("Reset");
			t12 = space();
			button1 = element("button");
			t13 = text("Random");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1sd5z0r\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Abilities");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			t3 = claim_space(div0_nodes);
			p = claim_element(div0_nodes, "P", {});
			var p_nodes = children(p);
			t4 = claim_text(p_nodes, "Buy Abilities for your Character using XP, or save some or all of your starting XP for later.");
			p_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h3 = claim_element(div1_nodes, "H3", {});
			var h3_nodes = children(h3);
			t6 = claim_text(h3_nodes, "Remaining: ");
			t7 = claim_text(h3_nodes, t7_value);
			h3_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t8 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			t9 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			t10 = claim_space(nodes);
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			button0 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t11 = claim_text(button0_nodes, "Reset");
			button0_nodes.forEach(detach_dev);
			t12 = claim_space(div3_nodes);
			button1 = claim_element(div3_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t13 = claim_text(button1_nodes, "Random");
			button1_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Apocalyptia Online - Character Creator - Abilities";
			add_location(h1, file$6, 23, 0, 722);
			add_location(p, file$6, 28, 1, 832);
			attr_dev(div0, "class", "explanation");
			add_location(div0, file$6, 24, 0, 741);
			add_location(h3, file$6, 31, 1, 965);
			attr_dev(div1, "class", "remaining");
			add_location(div1, file$6, 30, 0, 940);
			attr_dev(div2, "class", "abilities-list svelte-1147wm9");
			add_location(div2, file$6, 38, 0, 1148);
			attr_dev(button0, "class", "small-cntr-btn");
			add_location(button0, file$6, 44, 1, 1304);
			attr_dev(button1, "class", "small-cntr-btn");
			add_location(button1, file$6, 47, 1, 1373);
			attr_dev(div3, "class", "btn-row");
			add_location(div3, file$6, 43, 0, 1281);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, div0, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append_dev(div0, t3);
			append_dev(div0, p);
			append_dev(p, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, h3);
			append_dev(h3, t6);
			append_dev(h3, t7);
			insert_dev(target, t8, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t9, anchor);
			insert_dev(target, div2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			insert_dev(target, t10, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, button0);
			append_dev(button0, t11);
			append_dev(div3, t12);
			append_dev(div3, button1);
			append_dev(button1, t13);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*reset*/ ctx[3], false, false, false),
					listen_dev(button1, "click", /*random*/ ctx[2], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*Abilities*/ 0) {
				each_value_1 = Abilities.explanation;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, t3);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if ((!current || dirty & /*$character*/ 1) && t7_value !== (t7_value = /*$character*/ ctx[0].props.experience.remaining + "")) set_data_dev(t7, t7_value);

			if (/*$character*/ ctx[0].abilities.length) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$character*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t9.parentNode, t9);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*Abilities, MasterAbilityList*/ 2) {
				each_value = Abilities.groups;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div2, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div0);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t8);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t10);
			if (detaching) detach_dev(div3);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(0, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Abilities", slots, []);
	let MasterAbilityList = Abilities.masterList;
	const random = () => set_store_value(character, $character = Abilities.random($character), $character);
	const reset = () => set_store_value(character, $character = Abilities.reset($character), $character);

	beforeUpdate(_ => {
		set_store_value(character, $character.abilities = MasterAbilityList.filter(ability => ability.taken), $character);
		set_store_value(character, $character = Abilities.remainingXP($character), $character);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Abilities> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Abilities,
		AbilityCurrent,
		AbilityGroup,
		beforeUpdate,
		character,
		MasterAbilityList,
		random,
		reset,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("MasterAbilityList" in $$props) $$invalidate(1, MasterAbilityList = $$props.MasterAbilityList);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [$character, MasterAbilityList, random, reset];
}

class Abilities_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Abilities_1",
			options,
			id: create_fragment$6.name
		});
	}
}

export default Abilities_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJpbGl0aWVzLmE1MzY3YTA2LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eUN1cnJlbnQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL0FiaWxpdHlNb2RhbFNpbmdsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eU1vZGFsT3B0aW9ucy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eU1vZGFsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2hlbHBlcnMvdXRpbHMvVG9nZ2xlVmlzaWJsZS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9BYmlsaXR5Q2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eUdyb3VwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvY2hhcmFjdGVyL2NyZWF0b3IvYWJpbGl0aWVzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG5cblx0ZXhwb3J0IGxldCBNYXN0ZXJBYmlsaXR5TGlzdFxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz0nY3VycmVudC1hYmlsaXRpZXMnPlxuXHQ8ZGl2IGNsYXNzPSdjdXJyZW50LWFiaWxpdGllcy10aXRsZSc+Q3VycmVudCBBYmlsaXRpZXM8L2Rpdj5cblx0PGRpdiBjbGFzcz0nY3VycmVudC1hYmlsaXRpZXMtc2VjdGlvbic+XG5cdFx0PGRpdiBjbGFzcz0nY3VycmVudC1hYmlsaXRpZXMtaGVhZGVyJz5cblx0XHRcdDxzcGFuIGNsYXNzPSdsLWNvbCc+TmFtZTwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPSdzLWNvbCc+WFA8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz0ncy1jb2wnPk1heDwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPSdzLWNvbCc+VGFrZW48L3NwYW4+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0nY3VycmVudC1hYmlsaXRpZXMtbGlzdCc+XG5cdFx0XHR7I2VhY2ggJGNoYXJhY3Rlci5hYmlsaXRpZXMgYXMgYWJpbGl0eX1cblx0XHRcdFx0PGRpdiBjbGFzcz0nY3VycmVudC1hYmlsaXR5LXJvdyc+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9J2wtY29sJz5cblx0XHRcdFx0XHRcdHthYmlsaXR5Lm5hbWV9XG5cdFx0XHRcdFx0XHR7I2lmIGFiaWxpdHkub3B0c1swXX1cblx0XHRcdFx0XHRcdFx0Jm5ic3A7KHthYmlsaXR5Lm9wdHNbMF0ubmFtZX0pXG5cdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz0ncy1jb2wnPnthYmlsaXR5LnhwfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz0ncy1jb2wnPnthYmlsaXR5Lm1heH08L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9J3MtY29sJz5cblx0XHRcdFx0XHRcdDxzZWxlY3Rcblx0XHRcdFx0XHRcdFx0Y2xhc3M9J3Rha2VuLW51bWJlcidcblx0XHRcdFx0XHRcdFx0YmluZDp2YWx1ZT17YWJpbGl0eS50YWtlbn1cblx0XHRcdFx0XHRcdFx0b246Ymx1cj17KCkgPT4gJGNoYXJhY3Rlci5hYmlsaXRpZXMgPSBNYXN0ZXJBYmlsaXR5TGlzdC5maWx0ZXIoYWJpbGl0eSA9PiBhYmlsaXR5LnRha2VuKX1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyNlYWNoIEFycmF5KGFiaWxpdHkubWF4KzEpIGFzIF8sIGl9XG5cdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT17aX0+e2l9PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG5cblxuPHN0eWxlPlxuXHQuY3VycmVudC1hYmlsaXRpZXMge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG5cdC5jdXJyZW50LWFiaWxpdGllcy10aXRsZSB7XG5cdFx0Zm9udC1zaXplOiB2YXIoLS1zMTI1KTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblx0LmN1cnJlbnQtYWJpbGl0aWVzLWhlYWRlcixcblx0LmN1cnJlbnQtYWJpbGl0eS1yb3cge1xuXHRcdGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRtYXJnaW46IHZhcigtLXMxMDApIDA7XG5cdH1cblx0LmN1cnJlbnQtYWJpbGl0aWVzLWhlYWRlciB7XG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XG5cdFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG5cdH1cblx0LmwtY29sIHtcblx0XHRmbGV4OiAzO1xuXHR9XG5cdC5zLWNvbCB7XG5cdFx0ZmxleDogMTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuXG5cdGV4cG9ydCBsZXQgYWJpbGl0eSwgTWFzdGVyQWJpbGl0eUxpc3RcblxuXHRhYmlsaXR5ID0gTWFzdGVyQWJpbGl0eUxpc3QuZmlsdGVyKGEgPT4gYS5uYW1lID09IGFiaWxpdHkubmFtZSlbMF1cbjwvc2NyaXB0PlxuXG5cbjxkaXYgY2xhc3M9J29wdGlvbnMtc2VjdGlvbic+XG5cdDxkaXYgY2xhc3M9J2FiaWxpdHktc2VjdGlvbic+XG5cdFx0PGRpdiBjbGFzcz0nYWJpbGl0eS1uYW1lLWxhYmVsJz5cblx0XHRcdHthYmlsaXR5Lm5hbWV9XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0ndGFrZW4tbGFiZWwnPlRha2VuOlxuXHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRuYW1lPXthYmlsaXR5Lm5hbWV9XG5cdFx0XHRcdGJpbmQ6dmFsdWU9e2FiaWxpdHkudGFrZW59XG5cdFx0XHRcdG9uOmJsdXI9eygpID0+ICRjaGFyYWN0ZXIuYWJpbGl0aWVzID0gTWFzdGVyQWJpbGl0eUxpc3QuZmlsdGVyKGEgPT4gYS50YWtlbil9XG5cdFx0XHQ+XG5cdFx0XHRcdHsjZWFjaCBBcnJheShhYmlsaXR5Lm1heCsxKSBhcyBfLCBpfVxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9e2l9PntpfTwvb3B0aW9uPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHQ8L3NlbGVjdD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cblxuXG48c3R5bGU+XG5cdC5vcHRpb25zLXNlY3Rpb24ge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG5cdC5hYmlsaXR5LXNlY3Rpb24ge1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0Ym9yZGVyOiB2YXIoLS1zMSkgZGFzaGVkO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdG1hcmdpbjogdmFyKC0tczEwMCkgYXV0bztcblx0XHRwYWRkaW5nOiB2YXIoLS1zNTApO1xuXHR9XG5cdHNlbGVjdCB7XG5cdFx0d2lkdGg6IHZhcigtLXMzMDApO1xuXHR9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNoYXJhY3RlciB9IGZyb20gJ3N0b3Jlcy9jaGFyYWN0ZXJTdG9yZS5qcydcblxuXHRleHBvcnQgbGV0IGFiaWxpdHksIE1hc3RlckFiaWxpdHlMaXN0XG5cblx0bGV0IE9wdGlvbkxpc3QgPSBNYXN0ZXJBYmlsaXR5TGlzdC5maWx0ZXIoYSA9PiBhLm5hbWUgPT0gYWJpbGl0eS5uYW1lKVxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz0nb3B0aW9ucy1zZWN0aW9uJz5cblx0eyNlYWNoIE9wdGlvbkxpc3QgYXMgYWJpbGl0eX1cblx0XHQ8ZGl2IGNsYXNzPSdhYmlsaXR5LXNlY3Rpb24nPlxuXHRcdFx0PGRpdiBjbGFzcz0nYWJpbGl0eS1uYW1lLWxhYmVsJz5cblx0XHRcdFx0e2FiaWxpdHkub3B0c1swXS5uYW1lfVxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSd0YWtlbi1sYWJlbCc+VGFrZW46XG5cdFx0XHRcdDxzZWxlY3Rcblx0XHRcdFx0XHRuYW1lPXthYmlsaXR5Lm5hbWV9XG5cdFx0XHRcdFx0YmluZDp2YWx1ZT17YWJpbGl0eS50YWtlbn1cblx0XHRcdFx0XHRvbjpibHVyPXsoKSA9PiAkY2hhcmFjdGVyLmFiaWxpdGllcyA9IE1hc3RlckFiaWxpdHlMaXN0LmZpbHRlcihhID0+IGEudGFrZW4pfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyNlYWNoIEFycmF5KGFiaWxpdHkubWF4KzEpIGFzIF8sIGl9XG5cdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPXtpfT57aX08L29wdGlvbj5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdHsvZWFjaH1cbjwvZGl2PlxuXG5cbjxzdHlsZT5cblx0Lm9wdGlvbnMtc2VjdGlvbiB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblx0LmFiaWxpdHktc2VjdGlvbiB7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRib3JkZXI6IHZhcigtLXMxKSBkYXNoZWQ7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0bWFyZ2luOiB2YXIoLS1zMTAwKSBhdXRvO1xuXHRcdHBhZGRpbmc6IHZhcigtLXM1MCk7XG5cdH1cblx0c2VsZWN0IHtcblx0XHR3aWR0aDogdmFyKC0tczMwMCk7XG5cdH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnXG5cdGltcG9ydCBBYmlsaXR5TW9kYWxTaW5nbGUgZnJvbSAnLi9BYmlsaXR5TW9kYWxTaW5nbGUuc3ZlbHRlJ1xuXHRpbXBvcnQgQWJpbGl0eU1vZGFsT3B0aW9ucyBmcm9tICcuL0FiaWxpdHlNb2RhbE9wdGlvbnMuc3ZlbHRlJ1xuXG5cdGV4cG9ydCBsZXQgYWJpbGl0eSwgTWFzdGVyQWJpbGl0eUxpc3RcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cblx0Y29uc3QgaGFuZGxlX2tleWRvd24gPSBlID0+IHsgaWYgKGUua2V5ID09PSAnRXNjYXBlJykgZGlzcGF0Y2goJ2Nsb3NlJykgfVxuXG5cdGNvbnN0IHByZXZpb3VzbHlfZm9jdXNlZCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuXG5cdGlmIChwcmV2aW91c2x5X2ZvY3VzZWQpIG9uRGVzdHJveShfID0+IHByZXZpb3VzbHlfZm9jdXNlZC5mb2N1cygpKVxuPC9zY3JpcHQ+XG5cblxuPHN2ZWx0ZTp3aW5kb3cgb246a2V5ZG93bj17aGFuZGxlX2tleWRvd259Lz5cbjxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZ3JvdW5kXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbG9zZScpfT48L2Rpdj5cbjxkaXYgY2xhc3M9XCJtb2RhbFwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuXHQ8ZGl2IGNsYXNzPSdtb2RhbC1jb250ZW50Jz5cblx0XHQ8ZGl2IGNsYXNzPSdhYmlsaXR5LW5hbWUnPjxoMj57YWJpbGl0eS5uYW1lfTwvaDI+PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0nZGVzY3JpcHRpb24tc2VjdGlvbic+XG5cdFx0XHQ8c3BhbiBjbGFzcz0nZGVzY3JpcHRpb24tbGFiZWwnPkRlc2NyaXB0aW9uOjwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPSdhYmlsaXR5LWRlc2NyaXB0aW9uJz57YWJpbGl0eS5kZXNjfTwvc3Bhbj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPSdzdGF0cy1zZWN0aW9uJz5cblx0XHRcdHsjaWYgYWJpbGl0eS5vcHRzLmxlbmd0aH1cblx0XHRcdFx0PEFiaWxpdHlNb2RhbE9wdGlvbnMge2FiaWxpdHl9IHtNYXN0ZXJBYmlsaXR5TGlzdH0vPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8QWJpbGl0eU1vZGFsU2luZ2xlIHthYmlsaXR5fSB7TWFzdGVyQWJpbGl0eUxpc3R9Lz5cblx0XHRcdHsvaWZ9XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0nYnRuLXJvdyc+XG5cdFx0XHQ8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBkaXNwYXRjaCgnY2xvc2UnKX0+Q2xvc2U8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cblxuXG48c3R5bGU+XG5cdC5tb2RhbC1iYWNrZ3JvdW5kIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLDAuNyk7XG5cdFx0aGVpZ2h0OiAxMDB2aDtcblx0XHRsZWZ0OiAwO1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDEwMHZ3O1xuXHR9XG5cdC5tb2RhbCB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwuNSk7XG5cdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tcmFkaXVzKTtcblx0XHRib3JkZXI6IHZhcigtLXMxKSBzb2xpZDtcblx0XHRjb2xvcjogbGltZTtcblx0XHRoZWlnaHQ6IGZpdC1jb250ZW50O1xuXHRcdGxlZnQ6IDUwdnc7XG5cdFx0bWF4LWhlaWdodDogNzV2aDtcblx0XHRvdmVyZmxvdzogc2Nyb2xsO1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHRzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG5cdFx0dG9wOiA1MHZoO1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuXHRcdHdpZHRoOiA4MHZ3O1xuXHR9XG5cdC5tb2RhbC1jb250ZW50IHtcblx0XHRtYXJnaW46IHZhcigtLXMxMDApO1xuXHR9XG5cdC5idG4tcm93IHtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cblx0LnN0YXRzLXNlY3Rpb24ge1xuXHRcdGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0fVxuXHQuZGVzY3JpcHRpb24tc2VjdGlvbiB7XG5cdFx0bWFyZ2luLXRvcDogdmFyKC0tczEwMCk7XG5cdH1cblx0LmRlc2NyaXB0aW9uLWxhYmVsIHtcblx0XHRmb250LXdlaWdodDogYm9sZDtcblx0fVxuXHQ6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcblx0XHRkaXNwbGF5OiBub25lO1xuXHR9XG48L3N0eWxlPlxuIiwiZXhwb3J0IGRlZmF1bHQgKHgsIHk9bnVsbCkgPT4ge1xuXHR4LnZpc2libGUgPSAheC52aXNpYmxlXG5cdHJldHVybiB5XG59IiwiPHNjcmlwdD5cblx0aW1wb3J0IEFiaWxpdHlNb2RhbCBmcm9tICd2aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eU1vZGFsLnN2ZWx0ZSdcblx0aW1wb3J0IFRvZ2dsZVZpc2libGUgZnJvbSAndXRpbHMvVG9nZ2xlVmlzaWJsZS5qcydcblxuXHRleHBvcnQgbGV0IGFiaWxpdHksIE1hc3RlckFiaWxpdHlMaXN0XG48L3NjcmlwdD5cblxuXG48ZGl2IGNsYXNzPSdhYmlsaXR5LWNhcmQnIG9uOmNsaWNrPXsoKSA9PiBNYXN0ZXJBYmlsaXR5TGlzdCA9IFRvZ2dsZVZpc2libGUoYWJpbGl0eSwgTWFzdGVyQWJpbGl0eUxpc3QpfT5cblx0PGRpdiBjbGFzcz0nY2FyZC1yb3cnPlxuXHRcdDxzcGFuIGNsYXNzPSdhYmlsaXR5LW5hbWUnPnthYmlsaXR5Lm5hbWV9PC9zcGFuPlxuXHQ8L2Rpdj5cblx0PGRpdiBjbGFzcz0nY2FyZC1yb3cnPlxuXHRcdDxzcGFuIGNsYXNzPSdhYmlsaXR5LWRlc2NyaXB0aW9uJz57YWJpbGl0eS5kZXNjfTwvc3Bhbj5cblx0PC9kaXY+XG48L2Rpdj5cbnsjaWYgYWJpbGl0eS52aXNpYmxlID09IHRydWV9XG5cdDxBYmlsaXR5TW9kYWwgb246Y2xvc2U9J3soKSA9PiBNYXN0ZXJBYmlsaXR5TGlzdCA9IFRvZ2dsZVZpc2libGUoYWJpbGl0eSwgTWFzdGVyQWJpbGl0eUxpc3QpfSdcblx0XHR7YWJpbGl0eX1cblx0XHR7TWFzdGVyQWJpbGl0eUxpc3R9XG5cdC8+XG57L2lmfVxuXG5cbjxzdHlsZT5cblx0LmFiaWxpdHktY2FyZCB7XG5cdFx0Ym9yZGVyOiB2YXIoLS1zMSkgc29saWQ7XG5cdFx0bWFyZ2luOiB2YXIoLS1zMTAwKTtcblx0XHRwYWRkaW5nOiB2YXIoLS1zMTAwKTtcblx0fVxuXHQuYWJpbGl0eS1jYXJkOmhvdmVyIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBsaW1lO1xuXHRcdGNvbG9yOiByZ2JhKDE1LCAzMCwgMTUsIDEpO1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0fVxuXHQuY2FyZC1yb3cge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdG1hcmdpbjogdmFyKC0tczUwKSBhdXRvO1xuXHR9XG5cdC5hYmlsaXR5LW5hbWV7XG5cdFx0ZmxleDogMjtcblx0XHRmb250LXdlaWdodDogYm9sZDtcblx0XHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cblx0aW1wb3J0IEFiaWxpdHlDYXJkIGZyb20gJy4vQWJpbGl0eUNhcmQuc3ZlbHRlJ1xuXG5cdGV4cG9ydCBsZXQgZ3JvdXAsIE1hc3RlckFiaWxpdHlMaXN0XG48L3NjcmlwdD5cblxuXG48ZGV0YWlscyBjbGFzcz0nYWJpbGl0eS1ncm91cC1kZXRhaWxzJz5cblx0PHN1bW1hcnk+XG5cdFx0e2dyb3VwLm5hbWV9WFAgQWJpbGl0aWVzXG5cdDwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nYWJpbGl0eS1ncm91cC1jYXJkJz5cblx0XHR7I2VhY2ggZ3JvdXAubGlzdCBhcyBhYmlsaXR5fVxuXHRcdFx0PEFiaWxpdHlDYXJkIHthYmlsaXR5fSB7TWFzdGVyQWJpbGl0eUxpc3R9Lz5cblx0XHR7L2VhY2h9XG5cdDwvZGl2PlxuPC9kZXRhaWxzPlxuXG5cbjxzdHlsZT5cblx0LmFiaWxpdHktZ3JvdXAtZGV0YWlscyB7XG5cdFx0bWFyZ2luOiB2YXIoLS1zMTAwKTtcblx0fVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgQWJpbGl0aWVzIGZyb20gJ3J1bGVzL2FiaWxpdGllcy9BYmlsaXRpZXMuanMnXG5cdGltcG9ydCBBYmlsaXR5Q3VycmVudCBmcm9tICd2aWV3cy9jaGFyYWN0ZXIvQWJpbGl0eUN1cnJlbnQuc3ZlbHRlJ1xuXHRpbXBvcnQgQWJpbGl0eUdyb3VwIGZyb20gJ3ZpZXdzL2NoYXJhY3Rlci9BYmlsaXR5R3JvdXAuc3ZlbHRlJ1xuXHRpbXBvcnQgeyBiZWZvcmVVcGRhdGUgfSBmcm9tICdzdmVsdGUnXG5cdGltcG9ydCB7IGNoYXJhY3RlciB9IGZyb20gJ3N0b3Jlcy9jaGFyYWN0ZXJTdG9yZS5qcydcblxuXHRsZXQgTWFzdGVyQWJpbGl0eUxpc3QgPSBBYmlsaXRpZXMubWFzdGVyTGlzdFxuXG5cdGNvbnN0IHJhbmRvbSA9ICgpID0+ICRjaGFyYWN0ZXIgPSBBYmlsaXRpZXMucmFuZG9tKCRjaGFyYWN0ZXIpXG5cblx0Y29uc3QgcmVzZXQgPSAoKSA9PiAkY2hhcmFjdGVyID0gQWJpbGl0aWVzLnJlc2V0KCRjaGFyYWN0ZXIpXG5cblx0YmVmb3JlVXBkYXRlKF8gPT4ge1xuXHRcdCRjaGFyYWN0ZXIuYWJpbGl0aWVzID0gTWFzdGVyQWJpbGl0eUxpc3QuZmlsdGVyKGFiaWxpdHkgPT4gYWJpbGl0eS50YWtlbilcblx0XHQkY2hhcmFjdGVyID0gQWJpbGl0aWVzLnJlbWFpbmluZ1hQKCRjaGFyYWN0ZXIpXG5cdH0pXG48L3NjcmlwdD5cblxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5BcG9jYWx5cHRpYSBPbmxpbmUgLSBDaGFyYWN0ZXIgQ3JlYXRvciAtIEFiaWxpdGllczwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuPGgxPkFiaWxpdGllczwvaDE+XG48ZGl2IGNsYXNzPSdleHBsYW5hdGlvbic+XG5cdHsjZWFjaCBBYmlsaXRpZXMuZXhwbGFuYXRpb24gYXMgbGluZX1cblx0XHQ8cD57bGluZX08L3A+XG5cdHsvZWFjaH1cblx0PHA+QnV5IEFiaWxpdGllcyBmb3IgeW91ciBDaGFyYWN0ZXIgdXNpbmcgWFAsIG9yIHNhdmUgc29tZSBvciBhbGwgb2YgeW91ciBzdGFydGluZyBYUCBmb3IgbGF0ZXIuPC9wPlxuPC9kaXY+XG48ZGl2IGNsYXNzPSdyZW1haW5pbmcnPlxuXHQ8aDM+UmVtYWluaW5nOiB7JGNoYXJhY3Rlci5wcm9wcy5leHBlcmllbmNlLnJlbWFpbmluZ308L2gzPlxuPC9kaXY+XG57I2lmICRjaGFyYWN0ZXIuYWJpbGl0aWVzLmxlbmd0aH1cblx0PGRpdiBjbGFzcz0nc2VjdGlvbi1jYXJkJz5cblx0XHQ8QWJpbGl0eUN1cnJlbnQge01hc3RlckFiaWxpdHlMaXN0fS8+XG5cdDwvZGl2Plxuey9pZn1cbjxkaXYgY2xhc3M9J2FiaWxpdGllcy1saXN0Jz5cblx0eyNlYWNoIEFiaWxpdGllcy5ncm91cHMgYXMgZ3JvdXAsIGluZGV4fVxuXHRcdDxBYmlsaXR5R3JvdXAge2dyb3VwfSB7TWFzdGVyQWJpbGl0eUxpc3R9Lz5cblx0ey9lYWNofVxuPC9kaXY+XG48ZGl2IGNsYXNzPSdidG4tcm93Jz5cblx0PGJ1dHRvbiBjbGFzcz0nc21hbGwtY250ci1idG4nIG9uOmNsaWNrPXtyZXNldH0+XG5cdFx0UmVzZXRcblx0PC9idXR0b24+XG5cdDxidXR0b24gY2xhc3M9J3NtYWxsLWNudHItYnRuJyBvbjpjbGljaz17cmFuZG9tfT5cblx0XHRSYW5kb21cblx0PC9idXR0b24+XG48L2Rpdj5cblxuXG48c3R5bGU+XG5cdC5hYmlsaXRpZXMtbGlzdCB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQXNCZSxHQUFPLElBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0VBQXBCLEdBQU8sSUFBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQVlSLEdBQUM7Ozs7OztzQ0FBRCxHQUFDOzs7OzsrQ0FBTCxHQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFkakIsR0FBTyxJQUFDLElBQUk7Ozs7OzRCQUtPLEdBQU8sSUFBQyxFQUFFOzs7OzRCQUNWLEdBQU8sSUFBQyxHQUFHOzs7Ozs7Ozs0QkFMMUIsR0FBTyxJQUFDLElBQUksQ0FBQyxDQUFDO29CQVlYLEtBQUssYUFBQyxHQUFPLElBQUMsR0FBRyxHQUFDLENBQUM7Ozs7a0NBQXhCLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFITSxHQUFPLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQUFiLEdBQU8sSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozt3RUFWekIsR0FBTyxJQUFDLElBQUk7O21CQUNSLEdBQU8sSUFBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozt3RUFJQyxHQUFPLElBQUMsRUFBRTt3RUFDVixHQUFPLElBQUMsR0FBRzs7O21CQU92QixLQUFLLGFBQUMsR0FBTyxJQUFD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
